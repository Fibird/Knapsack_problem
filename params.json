{
  "name": "Knapsack problem",
  "tagline": "",
  "body": "# 0-1背包问题\r\n\r\n## 问题描述\r\n\r\n给定n个重量为w1,...,wn，价值为v1,...,vn的物品和一个承重量为W的背包，求这些物品中最有价值的一个子集，并且要能够装到背包中。\r\n\r\n## 动态规划算法\r\n\r\n为了设计一个动态规划算法，需要推导出一个递推关系，用较小实例的解的形式来表示背包问题的实例的解。让我们来考虑一个由前i个物品(1<=i<=n)定义的一个实例，物品的重量分别为w1,...,wi，价值分别为v1,...,vi，背包的承重量为j(1<=j<=W)。设V[i,j]为该实例的最优解的物品的总价值。可以把前i个物品中能够放进承重量为j的背包中的子集分成两个类别：包括第i个物品的子集和不包括第i个物品的子集。然后有下面的结论：\r\n\r\n1. 根据定义，在不包括第i个物品的子集中，最优子集的价值是V[i-1,j].\r\n2. 在包括第i个物品的子集中(因此，j-wi>=0)，最优子集是由该物品和前i-1个物品中能够放进承重量为j-wi的背包的最优子集组成。这种最优子集的总价值等于vi+V[i-1,j-wi]。\r\n\r\n因此，在前i个物品中最优解的总价值等于这两个价值中的较大值。当然，如果第i个物品不能放进背包，从前i个物品中选出的最优子集的总价值等于从前i-1个物品中选出的最优子集的总价值。这个结果导致了下面这个**递推式**：\r\n\r\n当j-wi>=0,V[i,j]=max{V[i-1,j],vi+V[i-1,j-wi]}\r\n\r\n当j-wi<0,V[i,j]=V[i-1,j]\r\n\r\n## 伪代码\r\n\r\n```\r\nKnapsack(w[0...n-1],V[0...n-1],W)\r\n// 用动态规划算法解决0-1背包问题\r\n// 输入：背包的容量W，各物品的重量w及其价值v\r\n// 输出：最大的价值及解集\r\n\r\nfor i from 0 to W - 1\r\n  v[0][j]<-0  // 当物品个数为0时，价值为0\r\nfor i from 0 to n-1\r\n  v[i][0]<-0  // 当承重量为0时，价值为0\r\nfor i from 1 to n - 1:\r\n  for j from 1 to W - 1:\r\n    if j <= w[i]:\r\n      v[i][j]<-v[i-1][j]\r\n    else:\r\n      v[i][j]<-max{v[i-1][j],v[i-1][j-w[i]]+Vi}\r\n\r\nwhile r != 0 && c!= 0:\r\n  if v[r][c] != v[r-1][c]:\r\n    Result U r    // 将第r个物品加入到解集中\r\n    c<-c-w[i]\r\n  r<-r-1\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}