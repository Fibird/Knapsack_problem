<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Knapsack problem by Sunlcy</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Knapsack problem</h1>
        <h2></h2>
        <a href="https://github.com/Sunlcy/Knapsack_problem" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="0-1背包问题" class="anchor" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>0-1背包问题</h1>

<h2>
<a id="问题描述" class="anchor" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>问题描述</h2>

<p>给定n个重量为w1,...,wn，价值为v1,...,vn的物品和一个承重量为W的背包，求这些物品中最有价值的一个子集，并且要能够装到背包中。</p>

<h2>
<a id="动态规划算法" class="anchor" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>动态规划算法</h2>

<p>为了设计一个动态规划算法，需要推导出一个递推关系，用较小实例的解的形式来表示背包问题的实例的解。让我们来考虑一个由前i个物品(1&lt;=i&lt;=n)定义的一个实例，物品的重量分别为w1,...,wi，价值分别为v1,...,vi，背包的承重量为j(1&lt;=j&lt;=W)。设V[i,j]为该实例的最优解的物品的总价值。可以把前i个物品中能够放进承重量为j的背包中的子集分成两个类别：包括第i个物品的子集和不包括第i个物品的子集。然后有下面的结论：</p>

<ol>
<li>根据定义，在不包括第i个物品的子集中，最优子集的价值是V[i-1,j].</li>
<li>在包括第i个物品的子集中(因此，j-wi&gt;=0)，最优子集是由该物品和前i-1个物品中能够放进承重量为j-wi的背包的最优子集组成。这种最优子集的总价值等于vi+V[i-1,j-wi]。</li>
</ol>

<p>因此，在前i个物品中最优解的总价值等于这两个价值中的较大值。当然，如果第i个物品不能放进背包，从前i个物品中选出的最优子集的总价值等于从前i-1个物品中选出的最优子集的总价值。这个结果导致了下面这个<strong>递推式</strong>：</p>

<p>当j-wi&gt;=0,V[i,j]=max{V[i-1,j],vi+V[i-1,j-wi]}</p>

<p>当j-wi&lt;0,V[i,j]=V[i-1,j]</p>

<h2>
<a id="伪代码" class="anchor" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>伪代码</h2>

<pre><code>Knapsack(w[0...n-1],V[0...n-1],W)
// 用动态规划算法解决0-1背包问题
// 输入：背包的容量W，各物品的重量w及其价值v
// 输出：最大的价值及解集

for i from 0 to W - 1
  v[0][j]&lt;-0  // 当物品个数为0时，价值为0
for i from 0 to n-1
  v[i][0]&lt;-0  // 当承重量为0时，价值为0
for i from 1 to n - 1:
  for j from 1 to W - 1:
    if j &lt;= w[i]:
      v[i][j]&lt;-v[i-1][j]
    else:
      v[i][j]&lt;-max{v[i-1][j],v[i-1][j-w[i]]+Vi}

while r != 0 &amp;&amp; c!= 0:
  if v[r][c] != v[r-1][c]:
    Result U r    // 将第r个物品加入到解集中
    c&lt;-c-w[i]
  r&lt;-r-1
</code></pre>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/Sunlcy/Knapsack_problem/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/Sunlcy/Knapsack_problem/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/Sunlcy/Knapsack_problem"></a> is maintained by <a href="https://github.com/Sunlcy">Sunlcy</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
